<!-- path_admin.html (ë¬¸ì œ ìˆ˜ + ê²€ìƒ‰ ê¸°ëŠ¥ í¬í•¨) -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ë¬¸ì œ ê°œë³„ ë“±ë¡ ë° ê²½ë¡œ ê´€ë¦¬</title>
  <style>
    body {
      font-family: 'Malgun Gothic', sans-serif;
      padding: 30px;
      max-width: 900px;
      margin: auto;
    }
    label {
      display: block;
      margin-top: 15px;
      font-weight: bold;
    }
    input, textarea, select {
      width: 100%;
      padding: 10px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      margin-top: 10px;
      margin-right: 5px;
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .success {
      color: green;
      font-weight: bold;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .path-group select {
      margin-bottom: 10px;
    }
    .section {
      margin-top: 50px;
    }
    .editable:hover {
      background-color: #eef;
      cursor: pointer;
    }
    ul.nested-sortable {
      list-style: none;
      padding-left: 20px;
    }
    .nested-sortable li {
      margin: 4px 0;
      padding: 4px;
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h2>ğŸ“Œ ìˆ˜í•™ ë¬¸ì œ ê°œë³„ ë“±ë¡</h2>
  <iframe src="add_problem.html" width="100%" height="700px" style="border:1px solid #ccc;"></iframe>

  <div class="section">
    <h2>â• ìƒˆ ê²½ë¡œ ì¶”ê°€ ë° ìˆ˜ì •</h2>
    <label>ìƒìœ„ ê²½ë¡œ ì„ íƒ</label>
    <select id="parent_path">
      <option value="0">ìµœìƒìœ„ (ì˜ˆ: ë”í”ŒëŸ¬ìŠ¤ìˆ˜í•™)</option>
    </select>

    <label>ìƒˆ ê²½ë¡œ ì´ë¦„</label>
    <input type="text" id="new_path_name" placeholder="ì˜ˆ: ê³ ë“±ìˆ˜í•™">
    <div>
      <button id="addPathBtn">ê²½ë¡œ ì¶”ê°€</button>
      <button id="deletePathBtn" disabled>ê²½ë¡œ ì‚­ì œ</button>
    </div>
    <p id="addPathMsg"></p>

    <h3>ğŸ“‚ ê²½ë¡œ ì´ë¦„ ìˆ˜ì •</h3>
    <label>ğŸ” ê²½ë¡œ ì´ë¦„ ê²€ìƒ‰</label>
    <input type="text" id="searchInput" placeholder="ì˜ˆ: ê³ ë“±ìˆ˜í•™">
    <ul id="editablePathList"></ul>

    <h3>ğŸ“¦ ê²½ë¡œ ë“œë˜ê·¸ë¡œ ì´ë™</h3>
    <ul id="dragTree" class="nested-sortable"></ul>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script>
    let flatPaths = [];
    let problemCounts = {};
    let selectedPathId = null;

    function fetchFlatPaths() {
      Promise.all([
        fetch('get_path_tree_flat.php').then(res => res.json()),
        fetch('count_problems.php').then(res => res.json())
      ]).then(([pathData, countData]) => {
        flatPaths = pathData;
        problemCounts = countData;
        renderParentDropdown(pathData);
        renderEditableList(pathData);
        renderDragTree(pathData);
        selectedPathId = null;
        document.getElementById('deletePathBtn').disabled = true;
      });
    }

    function renderParentDropdown(data) {
      const parentSelect = document.getElementById('parent_path');
      parentSelect.innerHTML = '<option value="0">ìµœìƒìœ„ (ì˜ˆ: ë”í”Œë«ìŠ¤ìˆ˜í•™)</option>';
      data.forEach(p => {
        const option = document.createElement('option');
        option.value = p.id;
        option.textContent = ' '.repeat(p.depth * 2) + p.name;
        parentSelect.appendChild(option);
      });
    }

    function renderEditableList(data) {
      const list = document.getElementById('editablePathList');
      list.innerHTML = '';
      data.forEach(p => {
        const count = problemCounts[p.id] || 0;
        const li = document.createElement('li');
        li.innerHTML = `<span class="editable" data-id="${p.id}">${'&nbsp;&nbsp;'.repeat(p.depth)}${p.name} (${count})</span>`;
        list.appendChild(li);
      });
      attachInlineRename();
    }

    function attachInlineRename() {
      document.querySelectorAll('.editable').forEach(span => {
        span.addEventListener('click', () => {
          const oldName = span.textContent.replace(/ \(\d+\)$/, '').trim();
          selectedPathId = span.dataset.id;
          document.getElementById("deletePathBtn").disabled = false;

          const input = document.createElement('input');
          input.type = 'text';
          input.value = oldName;
          input.style.width = '200px';
          span.replaceWith(input);

          input.focus();
          input.addEventListener('blur', () => {
            const newName = input.value.trim();
            if (newName && newName !== oldName) {
              fetch('update_path.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: selectedPathId, name: newName })
              })
              .then(res => res.json())
              .then(data => {
                if (data.success) fetchFlatPaths();
                else alert('ìˆ˜ì • ì‹¤íŒ¨: ' + data.message);
              });
            } else {
              fetchFlatPaths();
            }
          });
        });
      });
    }

    function renderDragTree(data) {
      const tree = document.getElementById('dragTree');
      tree.innerHTML = '';
      const map = new Map();

      data.forEach(item => {
        map.set(item.id, { ...item, children: [] });
      });

      data.forEach(item => {
        if (item.parent_id !== 0) {
          const parent = map.get(item.parent_id);
          if (parent) parent.children.push(map.get(item.id));
        }
      });

      const roots = [...map.values()].filter(x => x.parent_id === 0);
      roots.forEach(node => tree.appendChild(makeNodeElement(node)));

      Sortable.create(tree, {
        group: 'nested',
        animation: 150,
        onEnd: handleDragEnd
      });
    }

    function makeNodeElement(node) {
      const li = document.createElement('li');
      const count = problemCounts[node.id] || 0;
      li.textContent = `${node.name} (${count})`;
      li.dataset.id = node.id;

      const childrenUl = document.createElement('ul');
      childrenUl.className = 'nested-sortable';

      node.children.forEach(child => {
        childrenUl.appendChild(makeNodeElement(child));
      });

      li.appendChild(childrenUl);
      Sortable.create(childrenUl, {
        group: 'nested',
        animation: 150,
        onEnd: handleDragEnd
      });

      return li;
    }

    function handleDragEnd(evt) {
      const dragged = evt.item;
      const newParent = dragged.parentElement.closest('li');
      const newParentId = newParent ? parseInt(newParent.dataset.id) : 0;

      const siblings = [...dragged.parentElement.children];
      const newOrder = siblings.indexOf(dragged);

      const id = parseInt(dragged.dataset.id);
      fetch('move_path.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, new_parent_id: newParentId, new_order: newOrder })
      })
      .then(res => res.json())
      .then(data => {
        if (!data.success) alert('ì •ë ¬ ì €ì¥ ì‹¤íŒ¨: ' + data.message);
        fetchFlatPaths();
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      fetchFlatPaths();

      document.getElementById('addPathBtn').addEventListener('click', () => {
        const parent_id = document.getElementById('parent_path').value;
        const name = document.getElementById('new_path_name').value.trim();
        const msg = document.getElementById('addPathMsg');

        if (!name) {
          msg.textContent = 'ê²½ë¡œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”';
          msg.className = 'error';
          return;
        }

        fetch('insert_path.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ parent_id, name })
        })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            msg.textContent = 'âœ… ê²½ë¡œ ì¶”ê°€ ì„±ê³µ';
            msg.className = 'success';
            document.getElementById('new_path_name').value = '';
            fetchFlatPaths();
          } else {
            msg.textContent = 'âŒ ì‹¤íŒ¨: ' + data.message;
            msg.className = 'error';
          }
        });
      });

      document.getElementById('deletePathBtn').addEventListener('click', () => {
        if (!selectedPathId) return;

        if (!confirm("ì •ë§ë¡œ ì´ ê²½ë¡œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\ní•˜ìœ„ ê²½ë¡œê°€ ìˆì„ ê²½ìš° ì‚­ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")) return;

        fetch("delete_path.php", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: "id=" + encodeURIComponent(selectedPathId),
        })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            alert("ê²½ë¡œê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
            fetchFlatPaths();
          } else {
            alert("ì‚­ì œ ì‹¤íŒ¨: " + data.message);
          }
        })
        .catch(err => {
          alert("ì—ëŸ¬ ë°œìƒ: " + err);
        });
      });

      // ğŸ” ê²€ìƒ‰ ê¸°ëŠ¥ ì¶”ê°€
      document.getElementById('searchInput').addEventListener('input', function () {
        const keyword = this.value.toLowerCase();
        document.querySelectorAll('#editablePathList .editable').forEach(el => {
          const name = el.textContent.toLowerCase();
          el.style.backgroundColor = name.includes(keyword) ? '#ffff99' : '';
        });
      });
    });
  </script>
</body>
</html>
